import java.util.ArrayList;
import java.util.HashSet;
import java.util.Random;
import java.util.Scanner;

public class LinearRegressionTrainer {
	protected static String filePath="data.csv";
	protected static String[] inpHeaders= {"Landsize","Postcode"};
	protected static String[] outputHeader= {"Price"};
	protected static ArrayList<Double> values;
	protected static ArrayList<ArrayList<Double>> values_input = new ArrayList<ArrayList<Double>>();
	protected static Random rand=new Random();
	protected static double ratio=0.8;
	
	/**
	 * @param size
	 * @param ratio
	 * @return HashSet of the random indices of the training data in our data. 
	 */
	protected static HashSet<Integer> generateRandIndices(int size,double ratio) {
		assert(ratio>=0.0 && ratio<=1.0);
		int NTrain=(int)(ratio*size);
		HashSet<Integer> indices=new HashSet<>();
		for (int i=0;i<NTrain;++i) {
			while(true) {
				int nxt=rand.nextInt(NTrain);
				if (!indices.contains(nxt)) {
					indices.add(nxt);
					break;
				}
			}
		}
		return indices;
	}
	/**
	 * @param inp
	 * @param output
	 * @param inpTrain
	 * @param outputTrain
	 * @param inpTest
	 * @param outputTest
	 * @param ratio
	 * 
	 * This function splits our data into training and testing data using the indices 
	 * generated by the above function for the training data and the rest of the indices for the test data.
	 */
	protected static void splitData(
			ArrayList<ArrayList<Double>>inp,ArrayList<Double> output,
			ArrayList<ArrayList<Double>>inpTrain,ArrayList<Double> outputTrain,
			ArrayList<ArrayList<Double>>inpTest,ArrayList<Double> outputTest,
			double ratio) {
		
		assert(inp.size()==output.size());
		HashSet<Integer> indices=generateRandIndices(inp.size(),ratio);
		
		for (int i=0;i<inp.size();++i) {
			if (indices.contains(i)) {
				inpTrain.add(inp.get(i));
				outputTrain.add(output.get(i));
			}else {
				inpTest.add(inp.get(i));
				outputTest.add(output.get(i));
			}
		}
	}
	/**
	 * @param inp
	 * @param column
	 * @return
	 * 
	 * This function normalizes our features so that their ranges reman between 1 and zero. Thus the training is much faster. 
	 * It does so by subtracting from the average and divide by the range. 
	 */
	protected static ArrayList<Double> normalizeData(ArrayList<ArrayList<Double>> inp,int column) {
		assert(inp.size()>0);
		assert(column<inp.get(0).size());
		double mn=inp.get(0).get(column),mx=inp.get(0).get(column),sum=0,av,range;
		for (int i=0;i<inp.size();++i) {
			mn=Math.min(mn, inp.get(i).get(column));
			mx=Math.max(mx, inp.get(i).get(column));
			sum+=inp.get(i).get(column);
		}
		av=sum/inp.size();
		range=mx-mn;
		if (range==0) {range=1;}
		for (int i=0;i<inp.size();++i) {
			inp.get(i).set(column, (inp.get(i).get(column)-av)/range);
		}
		ArrayList<Double> values = new ArrayList<>();
		values.add(av);
		values.add(range);
		
		return values;
	}
	
	/**
	 * @param inp
	 * @param column
	 * @param values
	 * 
	 * This function does exactly as the above one except that it's used fot test time not training time. 
	 */
	protected static void normalizeDataInput(ArrayList<ArrayList<Double>> inp,int column, ArrayList<Double> values) {
		assert(inp.size()>0);
		assert(column<inp.get(0).size());

		double av= values.get(0);
		double range = values.get(1);
		
		if (range==0) {range=1;}
		for (int i=0;i<inp.size();++i) {
			inp.get(i).set(column, (inp.get(i).get(column)-av)/range);
		}

	}
	
	
	/**
	 * @param args
	 * Main method that runs our code
	 */
	public static void main(String[] args) {
		//Reading data. 
		SimpleCSVReader csv=new SimpleCSVReader(filePath);
		ArrayList<ArrayList<Double>> inp=csv.getTrainingData(inpHeaders);
		ArrayList<ArrayList<Double>> outputArr=csv.getTrainingData(outputHeader);
		//Normalizing data. 
		for (int i=0;i<inpHeaders.length;++i) {
			values_input.add(normalizeData(inp,i));
		}
		values = normalizeData(outputArr,0);
		
		ArrayList<Double> output=new ArrayList<>();
		for (int i=0;i<outputArr.size();++i){
			output.add(outputArr.get(i).get(0));
		}
		//Splitting data, training, and calculating the error.
		ArrayList<ArrayList<Double>> inpTrain=new ArrayList<>();
		ArrayList<ArrayList<Double>> inpTest=new ArrayList<>();
		ArrayList<Double> outputTrain=new ArrayList<>();
		ArrayList<Double> outputTest=new ArrayList<>();
		splitData(inp, output, inpTrain, outputTrain, inpTest, outputTest, ratio);
		LinearRegression reg=new LinearRegression(inpHeaders.length);
		reg.train(inpTrain, outputTrain);
		double err=reg.calcError(inpTest, outputTest);
		System.out.println("The error is "+err);
		
		//GUI part.
		LinearGUI f  = new LinearGUI();
		f.setSize(300, 300);
	    f.setVisible(true);
	    f.reg = reg;
		
		
	}

}
